# 结论

>总结一下 计算一个子树的链长或者是节点数，都可以递归 return 0以及 返回 + 1来做 
>
>不过 是传入root的一整棵数的话，最大节点数 = 最大边长 - 1。因为父亲节点没有上行边，而我们前面之所以说链长 = 节点数 是因为，一个节点看做了上行边 而对于直径这种题目的话，一条直径的边的长度，可以遍历枚举每一个节点，也就是等于，左边的最长路径 + 右边的最长路径。
>
>由于此时求的是子树的，所以可以当做求节点一样做。 而直径所经过的点的话，按照老规矩，还是需要加上转弯的这个枚举的点，也就是求的边长 + 1

## ✅ 树结构中链长、节点数、直径的本质总结

### 一、【子树中的链长 = 节点数 - 1，但可以用节点数思路递归求解】

> 在递归处理一个“子树”的最长路径（链长）或节点数时，可以统一使用以下模式：

```java
if (root == null) return 0;
int left = dfs(root.left);
int right = dfs(root.right);
return Math.max(left, right) + 1;
```

- 这里的返回值是“最大深度”，也就是**节点数**
- 而链长 = 节点数 - 1，但因为我们递归时默认“子树已经挂在某个父节点下面”，**那条“上行边”隐含存在**，所以链长和节点数在递归中可以视为等价使用

------

### 二、【整棵树的边数 = 节点数 - 1】

> 整棵树只有一个根节点，它没有父亲，所以缺少上行边。
>
> 因此，**整棵树的边数一定等于节点数 - 1**

------

### 三、【直径问题中的“最长路径”是边数，而不是节点数】

> 直径定义为：**任意两个节点之间路径的最长边数**
>
> 在求解时，通常我们枚举每个节点，假设它是“转折点”，则直径路径为：

```java
res = max(res, left + right); // 注意是 left + right，不包含当前节点自己
```

- `left/right` 是分别向下走的最长链的“节点数”
- `left + right` 实际上就是边数（中间转角点不算在路径里）

------

### 四、【如果你要算“直径路径上经过的节点数”，需要 +1】

> 如果面试问你直径经过了几个节点，那就是：

```java
节点数 = 最大边数 + 1
```

因为节点数 = 边数 + 1，这是通用路径关系。

## 🧠 写在你笔记里的一句话总结

> 🌳 **子树递归时：链长 = 节点数**（默认已有上行边）
>  🌲 **整棵树统计时：边 = 节点 - 1**（根节点没有上行边）
>  📏 **直径 = 左链长 + 右链长（边数），节点数 = 边数 + 1**