# 0-1背包问题 和完全背包问题

## 🔍 一、定义区别

| 类型         | 定义                                       |
| ------------ | ------------------------------------------ |
| **0-1 背包** | 每个物品只能选 **0 次或 1 次**（选或不选） |
| **完全背包** | 每个物品可以选 **无限次（多次）**          |

## 🧠 二、适用场景区别

| 类型         | 场景举例                                                     |
| ------------ | ------------------------------------------------------------ |
| **0-1 背包** | 给你一个物品集合，每种物品只给一个。例如：挑选若干装备进入背包 |
| **完全背包** | 给你一堆物品，每种物品无限个。例如：硬币兑换问题（每种面额可用多次） |



## 🔄 三、状态转移方程（二维）

### ✅ 0-1 背包

```
f[i][j] = max(
    f[i - 1][j],                    // 不选第 i 个物品
    f[i - 1][j - weight[i]] + val[i]  // 选第 i 个物品（只能一次）
)
```

### ✅ 完全背包

```
f[i][j] = max(
    f[i - 1][j],                    // 不选第 i 个物品
    f[i][j - weight[i]] + val[i]     // 选第 i 个物品（可以重复选）
)
```

### 🧨 本质区别：

- **0-1 背包：只能用一次 → 看的是上一行 `f[i-1][...]`**
- **完全背包：可以重复用 → 继续用本行 `f[i][...]`**





# 完全背包问题分为两种——排列和组合

## ✅ 一句话总结背包问题模板

| 问题类型        | 是否能重复 | 顺序是否重要 | 循环顺序                     | 一维是否可压缩 |
| --------------- | ---------- | ------------ | ---------------------------- | -------------- |
| 0-1 背包        | ❌ 不能重复 | 无关         | 外层物品，内层容量，容量倒序 | ✅              |
| 完全背包 - 组合 | ✅ 可重复   | ❌ 无关       | 外层物品，内层容量，容量正序 | ✅              |
| 完全背包 - 排列 | ✅ 可重复   | ✅ 有关       | 外层容量，内层物品，容量正序 | ✅              |



## 0-1背包的二维——推荐使用二维，一维容易出事

```java
int n = nums.length;
int m = target;
int[][] f = new int[n + 1][m + 1];

// 初始化：f[0][0] = 1 表示不选任何物品容量为 0 的方式有 1 种
f[0][0] = 1;

for (int i = 0; i < n; i++) {         // 枚举物品 i
    for (int j = 0; j <= m; j++) {    // 枚举容量 j
        if (j < nums[i]) {
            f[i + 1][j] = f[i][j];    // 当前物品装不下，只能不选
        } else {
            f[i + 1][j] = f[i][j] + f[i][j - nums[i]]; // 不选 + 选一次
        }
    }
}

```

* #### 这里就算 定义了`f[0][0]`，也是需要继续`i = 0`的，因为这个是二维数组，还有其他的这一行的元素需要初始化的。

## 完全背包——排列，在乎顺序

```java
int[] f = new int[target + 1];
f[0] = 1;

for (int j = 1; j <= target; j++) {
    for (int num : nums) {
        if (j >= num) f[j] += f[j - num];
    }
}

```

## 例题

```
377. 组合总和 Ⅳ
已解答
算术评级: 5
 同步题目状态

中等
相关标签
premium lock icon
相关企业
给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。
```

```java
class Solution {
    
    public int combinationSum4(int[] nums, int target) {

        // 可以重复选择
        // 回溯
        
        int[] f = new int[target + 1];

        f[0] = 1; // 也就是 触底之后 target归0之后，就是为1的

        for(int i = 1; i <= target; i++)
        {
            // 外层枚举体积，将每一个 f 都计算一下，内层的话，枚举一下 所有的可能性
            for(int j = 0; j < nums.length; j++)
            {
                if(nums[j] <= i)
                {
                    // 小于的话 才是有可能的
                    f[i] += f[i-nums[j]]; 
                }
            }


        }

        return f[target];

    }

}
```





## 完全背包——组合（不在乎顺序，物品在前，排列在后）

```java
int[] f = new int[target + 1];
f[0] = 1;

for (int num : nums) {
    for (int j = num; j <= target; j++) {
        f[j] += f[j - num];
    }
}

```

* #### 每一个大于 这个物品的容量，才进去维护。





# 注意：如果都是背包问题的话，也就是组合，都是外层物品，内层容量



# 策略：

* #### 背包问题：使用二维数组，一般都是初始化为 n + 1和m + 1

  * #### 物品在外，容量在内

* #### 排列问题：使用一维数组就可。

  * #### 容量在外，物品在内



# 先玩递归吧！将递归玩熟悉

# 还有这个cache，什么时候使用一维的cache什么时候使用而二维的cache呢？？



* #### 这个主要是取决于你：你合法的子问题 收到多少个条件的约束，比如受到了，你一定要从中选择数字的，一定要选完，且你的容量一定要满足的某个target，那么这个时候就是 二维的cache，因为你记录两个条件。否则的话 会出现覆盖。

* ## 🧠 什么是“状态空间的维度”？

  👉 状态空间维度 = **你要记忆的子问题需要依赖几个变量来唯一确定**

  简而言之：

  > #### **只要某个变量的变化会影响结果，就必须进 cache，下标要跟着它变**。只要状态会影响结果的话的，那么就必须进入到cache中去。
  >
  > ####  如果你忽略它，你就会重复计算不该重复的状态，或错误剪枝。



>给你一个非负整数数组 `nums` 和一个整数 `target` 。
>
>向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：
>
>- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。
>
>返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

* ## ❓一、你现在的写法到底出了什么问题？

  你用了这个函数签名：

  ```java
  int dfs(int[] nums, int p, int index, int[] cache)
  ```

  你的 `cache` 是：

  ```java
  int[] cache = new int[nums.length];
  ```

  你以为 `cache[index]` 就能唯一确定一个子问题的状态，但是——

  > ❌ **错了！状态不仅由 index 决定，还由 p 决定！**

  换句话说，**同一个 index，在不同的 p 值下，是完全不同的子问题！**



# 那么你这个记忆化搜索的扩容，怎么扩容呢？？

* #### 这个需要分情况讨论的。

## ✅ 一、记住：**递归状态变量的含义 = cache 的维度设计的依据**

### 1. `index` 从 `n-1 → 0`，终止条件 `index < 0`

✅ 不用扩容，`cache.length == n` 就够了
 📌 合法 index 是 `[0, n-1]`

### 2. `cap` / `target` / `rest` 这类「整数变量」

- 通常递归从 `cap == 初始容量` 开始往下减
- 最后终止在 `cap == 0`，甚至 `cap < 0` 剪枝

✅ **你必须扩容到 `cap + 1`**
 为什么？

> 因为数组下标是从 `0 ~ cap`，你要能表示所有合法的 `cap` 值。

## 🧠 二、你总结出的这句话是**真理**：

> ✅「扩容的根本目的，是为了让你能 safely 用下标 `cache[x][y]` 表示你要缓存的所有合法状态。」

再给你三个经典例子做对照：

| 状态变量                     | 是否扩容 | 解释                               |
| ---------------------------- | -------- | ---------------------------------- |
| `index: 0 → n-1`             | ❌ 不扩   | `new int[n]` 就够了，最大为 `n-1`  |
| `cap: 0 → C`                 | ✅ 要扩   | 因为 `dp[0] ~ dp[C]`，必须是 `C+1` |
| `i: 0 → n`（特别是完全背包） | ✅ 要扩   | 因为 `i == n` 也可能是一个有效状态 |



# 









