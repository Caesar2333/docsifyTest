# 大key问题怎么解决

## ✅ 一、什么是 Redis 的「大 Key」问题？

### 🔹【定义】

> Redis 中的某个 Key 对应的 **value 太大**，大到影响操作的性能或资源使用，就叫做 **大 Key（Big Key）**。

------

### 🔹【表现形式：Key 对应的值太大，有两种常见形式】

| 类型       | 举例                                           |
| ---------- | ---------------------------------------------- |
| 大字符串   | 一个 `key -> 10MB` 的 JSON、HTML、日志         |
| 大集合类型 | 一个 List / Hash / ZSet / Set 中有几十万条元素 |



### 🔹【为什么这会是问题？】

Redis 是单线程的，一条命令执行时间过长会阻塞其他命令的执行。

如果你对大 Key 进行如下操作：

- `GET key`（字符串很大）
- `LRANGE myList 0 -1`（全量遍历 list）
- `HGETALL bigHash`（大 hash）
- `DEL bigKey`（释放内存也要时间）
- `UNLINK bigKey`（虽然异步，但仍有影响）

💥 会导致：

- Redis 卡顿甚至阻塞一整段时间
- QPS 突然下降，其他用户“卡死”现象
- CPU 飙升（序列化、反序列化、内存复制开销大）
- 慢日志或监控出现突刺

------

## ✅ 二、为什么会产生大 Key？

| 场景               | 原因                                                    |
| ------------------ | ------------------------------------------------------- |
| 一次性写入大量数据 | 比如用户购物车是 Hash，直接放了几万条商品               |
| 无限制缓存字符串   | 比如将整个页面 HTML 存成一个字符串                      |
| 存储全量排行榜     | ZSet 中放了几十万用户分数                               |
| 接口缓存           | 某个接口返回数据大，但你没分片缓存，直接 SET 了整个响应 |



## ✅ 三、大 Key 会带来什么风险？

### ❌ 性能风险：

- 单个请求耗时几百毫秒甚至秒级，影响整个 Redis 实例的 QPS
- 删除大 Key 会**阻塞事件循环**，尤其在高并发下是灾难

### ❌ 内存碎片问题：

- Redis 管理内存时会导致堆碎片率增加，甚至频繁触发内存整理（耗 CPU）

### ❌ 集群风险：

- 如果用的是 Redis Cluster，一个大 Key 会导致 **某个 slot 极度不均衡**，拖垮单个节点

------

## ✅ 四、怎么排查 Redis 中是否存在大 Key？

### 🔍 方法 1：使用 Redis 官方命令

```
# 查 key 所占字节
MEMORY USAGE key

# 获取集合大小
LLEN listKey
SCARD setKey
HLEN hashKey
ZCARD zsetKey
```

### 🔍 方法 2：使用 scan + memory usage 脚本遍历

```
# 慢，但可全量扫描
SCAN 0 COUNT 1000
```

------

## ✅ 五、怎么解决大 Key 问题？

### ✅ 1. 拆分大 Key（分片）

- 不要存 `user:cart` → 超长 hash
- 而是拆成 `user:cart:sku1`，`user:cart:sku2`，每个商品单独是一个 key

### ✅ 2. 限制集合大小（分段）

- List 拆成 `list:001`, `list:002`……
- ZSet 排行榜可以分页分 Key，比如 `rank:1_100`, `rank:101_200`

### ✅ 3. 避免一次性全量操作

- 不要用 `LRANGE 0 -1`，用分页获取 list，比如 `LRANGE 0 99`
- 不要 `HGETALL`，用 `HSCAN` + 游标方式分页

### ✅ 4. 慎用大 value 的字符串缓存

- 不要缓存 5MB 的 JSON；考虑结构化存储、拆 key

### ✅ 5. 删除时使用 UNLINK 替代 DEL

```
// Java 示例
stringRedisTemplate.unlink("bigKey"); // 异步删除，避免阻塞主线程
```

------

## ✅ 六、一句话总结

> **大 Key 是 Redis 的“炸弹”，不爆时无感，一爆就是全体阻塞。**

Redis 不适合存储“单个 key 巨大”的数据，更适合海量小 key。







