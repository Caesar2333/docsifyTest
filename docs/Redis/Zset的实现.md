# Zset的底层是怎么实现的？？

## ✅ 一、ZSet 是什么？

**`ZSet` 是 Redis 中的「<u>有序集合</u>」，每个元素都有一个唯一的 member（值），以及一个 score（分数），Redis 会根据 `score` 从小到大排序所有元素。**

* #### **它最常用于排行榜、范围查询、TopN 等场景。**

## ✅ 再强调一遍结构：ZSet = 二元组集合

- Redis 的 **ZSet 是一个有序集合**，其内部每一个元素都是：

  ```css
  (member, score)
  ```

- 不要搞混成 Hash 的结构：`field → value`（Hash 是典型的键值对）

* #### Zset的key指向的是一整个sorted set的数据结构，这个set中都是二元组、



## ✅ 和 Hash 对比一下，避免混淆：

| 类型 | 数据结构                | 元素结构                | 支持排序？          |
| ---- | ----------------------- | ----------------------- | ------------------- |
| Hash | key → {field → value}   | 典型的“键值对”          | ❌ 无序              |
| ZSet | key → {(member, score)} | 二元组（member + 分数） | ✅ 支持按 score 排序 |

------

## ✅ 二、ZSet 的底层结构是「哈希表 + 跳表」：

| 数据结构 | 存储内容                       | 功能                                           |
| -------- | ------------------------------ | ---------------------------------------------- |
| 哈希表   | `member -> score` 映射         | 快速定位某个元素的分数（时间复杂度 O(1)）      |
| 跳表     | `(score, member)` 结构有序排列 | 按分数范围查询、排序、前 N 名、分页（O(logN)） |

两者存的是「同一份数据」，但视角不同：

- 哈希表强调 **“定位某个值”**
- 跳表强调 **“维护一个有序结构”**



# 为什么Zset需要使用两个数据结构？

## ✅ 三、为啥要双结构？单靠跳表或哈希表不行吗？

### ❌ 只用哈希表不行：

哈希表虽然查找快（O(1)），但它是「无序的」！你不能对它做：

- `ZRANGE 0 10`
- `ZRANGEBYSCORE 100 200`
- `ZREVRANK member`

这些都需要有序结构，而哈希表做不到。

------

### ❌ 只用跳表不行：

跳表虽然能排序、区间查询，但你找一个具体 `member` 的 `score`，只能全表遍历 O(logN)，不如哈希表快。

------

### ✅ 所以 Redis 选择了 “双结构” 的设计思路：

- 哈希表负责：**快速查找 member → score**
- 跳表负责：**按 score 排序 + 区间查询**

而这两份结构是 **同时维护** 的，插入、删除、更新时都会对它们进行同步操作，确保一致性。

------

## ✅ 四、设计背后的哲学：空间换时间 + 读优化

这种设计体现了 Redis 的典型特性：

- #### 为了查询快（时间效率），牺牲一些内存（空间效率）

- 典型的“读多写少”结构优化方向

- 与 Redis 的定位（高性能读写缓存）完全匹配

### 🔚 这一部分总结：

| 目的/场景              | 使用的数据结构 |
| ---------------------- | -------------- |
| 快速查找某个元素的分数 | 哈希表 O(1)    |
| 排序、范围查询、分页   | 跳表 O(logN)   |





# 跳表是什么？？增删改查是什么？？

### ✅ 一、跳表的本质是什么？

跳表（Skip List）是一个带“加速通道”的**<u>多级链表结构</u>**，目标是：**在链表基础上实现 O(logN) 的查找、插入、删除**，类似于“链表版的平衡树”。

核心理念：

> “链表太慢，数组太死板，能不能搞个能跳跃的链表？”



## 跳表每一层索引的节点是怎么选举出来的

### 📌 背后原理

跳表的每一层都是**上一层的子集**，新节点插入后会“随机”决定参与几层。
 这个层数是通过**抛硬币**的方式（概率模型）决定的：

- 概率为 **p**，那么：
  - 参与第1层的概率：100%
  - 参与第2层的概率：p（比如 1/4）
  - 参与第3层的概率：p²（比如 1/16）
  - …
  - 层数最多为 `MAX_LEVEL`（Redis 默认为 32）



### ✅ 本质：**完全随机，不靠固定间隔**

Redis 使用了 **概率方式**来决定每个节点的“高度”（也就是会出现在几层索引中），而不是靠人工“每隔 N 个选一个”。具体机制如下：

1. **插入时调用 `zslRandomLevel()` 随机决定节点高度**

   ```
   int zslRandomLevel(void) {
       int level = 1;
       // ZSKIPLIST_P = 0.25
       while ((random() & 0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
           level += 1;
       return (level < ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
   }
   ```

   每次 level 增加的概率是 25%，最高不超过 32 层。

2. **随机决定节点高度**

   - Level 1：必定拥有（100%）
   - Level 2：25% 概率
   - Level 3：25% × 25% = 6.25%
   - Level 4：25%³ ≈ 1.56%
      …
      统计上，高层节点越来越少 。

3. **没有固定“每隔多少个选一个”**
    每个节点独立决定是否晋级，插入时自然生成多层索引。这种“概率晋升”方式产生了 **指数递减的层级结构**，平均层数大约是 `log₍1/P₎ N`，高度为 O(logN) [juejin.cn+1juejin.cn+1](https://juejin.cn/post/7048887104897548325?utm_source=chatgpt.com)。



## 跳表的查找过程是怎么样的

### ✅ 跳表的真实查找流程（以查找 key = F 为例）

------

### ✅ 跳表结构（模拟）

假设我们有这样一个跳表，存的是按照字母排序的 key：

```
Level 3:       [A] ------------> [G]
Level 2:       [A] ----> [C] --> [G]
Level 1:  [A]→[B]→[C]→[D]→[E]→[F]→[G]→[H]
```

------

### ❗错误理解（很多人以为的）：

> 从 Level 3 的 A 开始
>  → 一直跳 → 到 G
>  → G > F，不行了，进入 Level 2
>  → 从 Level 2 的 A 开始跳
>  → 又跳到 G → 继续 Level 1
>  → 从 A 又跳起 → ……

❌这就像你坐电梯坐到楼上，又走回一楼重新开始 —— 真是**前面跳个寂寞**。

------

### ✅ 正确的跳表查找过程（非常像二维路径压缩）：

> **每一层继续“接力跳跃”，不是重新从头开始！**

------

### 🔍 举例：查找 key = `F`

1. **从 Level 3 的 `head` 节点开始**，当前节点是 `A`
2. **判断 A.forward = G**，发现 `G > F`，不能再跳
3. **下降到 Level 2**，**从刚刚的 A 节点继续查**
4. A.forward = C，`C < F`，跳到 `C`
5. C.forward = G，`G > F`，不能跳，下降到 Level 1
6. 从 `C` 继续，C → D → E → F ✅ 找到了

------

### 💡 关键点解释：

- **每次跳跃不是重头开始，而是“当前位置继续跳”**
- 把跳表理解成“楼层 + 快捷通道”的网格结构，每层都有自己的前进指针
- **一旦当前层跳不过了，就往下继续，而不是回头**

------

### ✅ 类比：就像在商场找某个商品，你会怎么走？

> 你站在 3 楼（Level 3），发现 F 在 G 前，G 在你面前 → 下楼
>  到了 2 楼（Level 2）继续从你**刚才站的位置**往前走，而不是从电梯口重新走
>  到了 1 楼（Level 1），继续往前直到找到 F

这就是跳表效率高的核心——**跳跃 + 不回头 + 多层接力**



## 跳表的插入是什么过程

### 🎯 场景举例

```java
ZADD top 50 "Alice"
```

跳表原本结构（简化成 Level 3~1）：

```java
L3: [A] -------> [G]
L2: [A] --> [C] --> [G]
L1: [A]→[B]→[C]→[D]→[E]→[F]→[G]
```

### 插入步骤：

#### 🔍 Step 1：查找插入位置（从高到底）

- 从 L3 的 A → G，G > 50 → 下降
- L2 的 A → C → G，G > 50 → 下降
- L1 从 C → D → E，发现 E < Alice → F → 插在 F 前面

#### 📍 Step 2：记录每一层的“前驱指针”路径（update[] 数组）

这个数组是维护每层“当前节点的前一个节点”，为插入指针调整做准备

#### 🎲 Step 3：抛硬币决定新节点高度，比如为 2 层

#### 🔗 Step 4：调整每一层指针 forward/span，插入新节点

```
插入成功后结构如下：
L3: [A] --------> [G]
L2: [A] --> [C] --> [Alice] --> [G]
L1: [A]→[B]→[C]→[D]→[E]→[F]→[Alice]→[G]
```

👉 每层插入都修改 `forward` 指针、`span` 距离，`backward` 也更新



## 跳表的改是什么过程？

### 🔴 二、删除节点：`ZREM key member`

### 🎯 场景举例

```
ZREM top "C"
```

当前结构（简化）：

```
L2: [A] --> [C] --> [F]
L1: [A]→[B]→[C]→[D]→[E]→[F]
```

### 删除步骤：

#### 🔍 Step 1：从高到底查找 C，记录每层“前驱 update[]”

- Level 2：A → C，找到 → 进入 update[]
- Level 1：B → C，找到 → 进入 update[]

#### ❌ Step 2：将每一层中 C 的 `forward` 指针删掉

- A.forward[2] → 指向 F
- B.forward[1] → 指向 D

#### 🧹 Step 3：释放内存（Redis 的 zslFreeNode）

删除后结构：

```
L2: [A] ---------> [F]
L1: [A]→[B]→[D]→[E]→[F]
```

#### ⚠️ 注意：

如果删除的是当前最高层唯一节点，该层级就废弃，跳表层级减少（maxLevel--）



## 跳表删除的过程是什么？？

### 🟡 三、更新节点 score：本质是删除 + 插入

### 🎯 场景举例：

```
ZADD top 85 "E"  // 原来 E 的分数是 60
```

### 为什么不能原地更新？

因为跳表是按 `(score, member)` 排序的结构，一旦 score 改变，顺序可能改变。

Redis 的 ZSet 更新过程：

1. `ZREM top "E"`：先删除原节点
2. `ZADD top 85 "E"`：按新分数重新插入

这两个操作就是刚才讲的“删 + 增”，所以复杂度是：

```
ZADD（存在 → 改分数） = O(logN) + O(logN) = O(logN)
```





## 为什么查找的效率是logn呢？？

### 🔍 为什么用logn？

随机层数让整个跳表在概率上维持平衡（节点越多的层越低，越高的层越稀疏）：

- 第 1 层的节点数量：N
- 第 2 层大概是 N/4
- 第 3 层大概是 N/16
- ...
- 总层数是 O(logN)

* 这正好和「二叉搜索树的高度」在一个量级，复杂度保持在 O(logN)。

这比手动旋转（像 AVL、红黑树）要简单得多，而且并发性也更强。

* #### 是的，跳表中每一个新插入的节点都会参与层数选举；并且选举是独立进行的，层数由 1/4 的概率随机晋升。

* #### 那么这样的话，每一层的数量都是上一层的1/4，这就有点像二分的思想，只不过好像是四分。

* #### 最后的话，层数近似于 `log4n`，所以查找就是 `log4n`





# 为什么底层使用跳表而不是AVL树和红黑树呢？

>#### 首先要明确的一点是：选择某项技术的根本原因是：只有它能实现我的目标，其他技术无法满足这个需求。

### ✅ 先看目标需求：ZSet 需要支持的典型操作

| 操作                      | 举例                   | 期望复杂度  |
| ------------------------- | ---------------------- | ----------- |
| 添加成员                  | `ZADD`                 | O(logN)     |
| 删除成员                  | `ZREM`                 | O(logN)     |
| 查找成员 score            | `ZSCORE`               | O(1)        |
| 查找第几名                | `ZRANK`                | O(logN)     |
| 查找某区间成员            | `ZRANGE by score/rank` | O(logN + K) |
| 查找 score 范围内的成员数 | `ZCOUNT`               | O(logN)     |

这不是单纯的“查找”，而是：

> #### 又要高效插入/删除，既要支持“范围有序遍历”，还要能支持重复分值的成员排序。

### 🧱 红黑树 / AVL 树不适合的原因：

#### ❌ AVL / 红黑树

- 插入/删除要频繁旋转，写入成本高
- 顺序遍历虽然是 O(N)，但 range 查询效率不如跳表灵活。不够灵活
- 不易支持 rank（排名）操作 —— 因为没有天然“排名”语义，除非维护子树大小

#### ❌ 堆（最大/最小）

- 只能取 topK，无法任意区间查询
- 不支持范围查找、rank 查询







# Zset的功能都是怎么通过hash表和跳表配合使用的？

## ✅ 第二部分：ZSet 的各种操作是怎么利用哈希表和跳表实现的？

我们来分析你给出的每个操作：

| 操作名               | 举例     | 时间复杂度  | 用到的结构    | 实现逻辑说明                      |
| -------------------- | -------- | ----------- | ------------- | --------------------------------- |
| 添加成员             | `ZADD`   | O(logN)     | 跳表 + 哈希表 | 哈希表查重；跳表插入位置          |
| 删除成员             | `ZREM`   | O(logN)     | 跳表 + 哈希表 | 哈希表查到后删；跳表找位置删      |
| 查找成员 score       | `ZSCORE` | O(1)        | 哈希表        | 哈希表直接查                      |
| 查找第几名（排名）   | `ZRANK`  | O(logN)     | 跳表          | 跳表中的 span 记录 rank           |
| 区间查询（范围成员） | `ZRANGE` | O(logN + K) | 跳表          | 跳表跳到起始点 + 遍历 K 个元素    |
| 范围内成员数量       | `ZCOUNT` | O(logN)     | 跳表          | 跳表跳到起始+结束点，用 span 相减 |



## 主要是这个Span，是范围查找的利器，也是查找rank的利器

### ✅ 1. 节点结构中维护“跨度”（span）来辅助快速定位 rank

每个跳表节点的每一层都有：

- 指向下一个节点的指针
- 当前节点到下一个节点之间的“跨度”（有多少个节点）

🔍 例子：

```less
Level 2:  [A] --(3)---> [D]
Level 1:  [A] -1-> [B] -1-> [C] -1-> [D]
```

这样一来：

- 想知道 A → D 之间有几个节点，直接加 span
- 查询“第 K 名”元素：每次跳的时候同时累计 span，即可快速算排名



## 🧠 下面我用图示 + 分析讲几个重点操作实现：

------

### 1️⃣ `ZADD key score member` 添加成员

- 查询哈希表是否存在 `member`
- 若存在则更新 score：需先删除跳表中旧节点，再插入新节点
- 若不存在：
  - 哈希表中新增 `member → score`
  - 跳表中找到正确位置插入（多层更新）

👉 跳表插入：从顶层往下搜索插入点，更新前后指针，O(logN)

------

### 2️⃣ `ZREM member` 删除成员

- 哈希表查出 `score`
- 在跳表中从高层开始，寻找 `(score, member)` 对应位置，更新前后指针
- 删除该节点并释放内存
- 同时从哈希表中删除键

------

### 3️⃣ `ZSCORE member` 查找某个成员的分数

- 哈希表直接查，O(1)
- 跟跳表无关

------

### 4️⃣ `ZRANK member` 查找该成员排名

- 在跳表中从高层开始搜索 `member`
- 每一层通过 `span` 计数：它记录当前节点与下一个节点之间的“跳跃个数”
- 所以在搜索过程中不断累计 `span` 就能得到当前 member 的排名

👉 时间复杂度 O(logN)

------

### 5️⃣ `ZRANGE start stop` 或 `ZRANGEBYSCORE min max`

- 对于 `ZRANGE`（按 rank）：
  - 直接在跳表按 rank 跳到起始节点（通过 span）
  - 然后顺序遍历 K 个节点
- 对于 `ZRANGEBYSCORE`（按 score）：
  - 在跳表中按 score 找到 >= min 的第一个节点
  - 然后顺序遍历，直到 score > max 为止

👉 总体是：O(logN) 跳到第一个节点 + O(K) 遍历 K 个元素

------

### 6️⃣ `ZCOUNT min max` 查询 score 区间个数

- 跳表查出起始位置 `min`（O(logN)）

- 跳表查出结束位置 `max`（O(logN)）

- 通过节点之间的 span 值相减得到总个数。

  - #### 从起点到max的span减去从起点到min的span = 区间的个数了。

👉 复杂度：O(logN)





















# 