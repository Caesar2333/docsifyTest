# 联合索引？

## ✅ 一、什么是联合索引？

假设你有这样一个索引：

```
CREATE INDEX idx_user ON user(name, age, email);
```

这是一个 **联合索引**，包含了字段：`name` → `age` → `email`

👉 **它的内部结构其实是按 name 排序，其次是 age，再其次是 email**

## ✅ 二、什么是最左前缀原则？

### 📌 定义：

> 使用联合索引时，**必须从最左边的字段开始连续使用**，才能命中索引。

### ✅ 举例说明：

联合索引 `(name, age, email)`：

| 查询条件                             | 是否命中索引  | 原因                                      |
| ------------------------------------ | ------------- | ----------------------------------------- |
| `WHERE name = 'Tom'`                 | ✅ 命中        | 使用了最左字段                            |
| `WHERE name = 'Tom' AND age = 20`    | ✅ 命中        | 连续使用 name、age                        |
| `WHERE age = 20`                     | ❌ 不命中      | 跳过了最左字段 name                       |
| `WHERE age = 20 AND email = 'x'`     | ❌ 不命中      | 跳过了最左字段 name                       |
| `WHERE name = 'Tom' AND email = 'x'` | ✅**部分命中** | 使用了 name，但 age 被跳过，只用到了 name |
| `WHERE name LIKE 'To%'`              | ✅ 命中        | 最左前缀字符串可以使用索引                |
| `WHERE name LIKE '%om'`              | ❌ 不命中      | 左侧有模糊匹配，前缀无法用索引了          |

## ✅ 三、最左前缀原则的底层原理

### 📌 InnoDB 的 B+ 树索引存储方式：

对于联合索引 `(name, age, email)` 来说，它构建的 B+ 树结构中：

```
key = (name, age, email)
```

节点是复合键，如：

```
('Alice', 20, 'a@example.com')
('Alice', 21, 'b@example.com')
('Bob', 20, 'c@example.com')
```

👉 所以查找必须从“最左”的字段开始，才能利用 B+ 树的有序性快速定位。

如果你跳过了 `name` 去查 `age`，B+ 树无法精准定位位置 → **退化为全表扫描**

## ✅ 四、最左前缀原则在**范围查询**中的坑

```
WHERE name = 'Tom' AND age > 20 AND email = 'x'
```

解释：

- name 是常量，OK ✅
- age 是范围查询，OK ✅
- email 无法使用索引 ❌

📌 结论：**一旦中间某字段是范围查询（`>、<、BETWEEN、LIKE`），后面的字段无法再用索引了！**

## ✅ 五、设计索引时如何利用最左前缀原则？

| 目标                           | 建议                                         |
| ------------------------------ | -------------------------------------------- |
| 频繁用 `name` 筛选，再用 `age` | 创建 `(name, age)`                           |
| 经常只用 `age` 查询            | 那就单独建 `age` 索引                        |
| 查询字段顺序很灵活             | 可考虑多列索引 + 覆盖索引，或者改写 SQL 结构 |

## ✅ 六、最左前缀总结口诀

> **“连续命中，从左到右，中断即止”**

一旦索引字段中间跳过一个字段或出现范围，就无法继续使用后面的字段。

## ✅ 七、常见误区

| 误区                                        | 正解                                             |
| ------------------------------------------- | ------------------------------------------------ |
| `(a, b)` 联合索引能加速 `b = ?` 吗？        | ❌ 不行，除非你也加了 `a = ?`                     |
| `(a, b)` 是不是等于两个单独索引？           | ❌ 不等，联合索引是组合排序的，不是单字段索引合集 |
| `a = ? AND b > ? AND c = ?` 可以用到 c 吗？ | ❌ 不行，b 是范围，c 失效了                       |



# 优化器怎么优化联合索引的左前缀

## ✅ 一、MySQL 查询流程回顾（简化版）

```
客户端 SQL
   ↓
Server 层：
   SQL解析器 → 预处理器 → 查询优化器（Optimizer） → 执行计划
   ↓
InnoDB 存储引擎：
   B+ 树索引扫描、回表、数据读取
```

### 📌 所以：“最左前缀规则”本质是 InnoDB 层的限制

—— **但优化器在 Server 层可以“试图”调整你的 SQL 结构，重新利用索引**

## ✅ 二、优化器可以优化哪些“最左前缀违背”的情况？

### ✅ 场景一：改写字段顺序、生成可用索引结构（靠索引下推 + 条件改写）

```
-- 联合索引：(a, b)
-- 查询语句：
SELECT * FROM t WHERE b = 2 AND a = 1;
```

虽然看起来是 b 在前，a 在后，**但优化器会把 WHERE 条件统一起来识别为 (a=1 AND b=2)**，重新判断能否用上 (a, b) 的复合索引。

📌 ✅ 实际上是命中索引的

------

### ✅ 场景二：条件改写为 IN + AND 的形式

```
-- 联合索引：(a, b)
SELECT * FROM t WHERE a IN (1, 2) AND b = 3;
```

虽然 IN 会生成多个执行计划（多路并发走索引），优化器会改写为：

```
(a = 1 AND b = 3) OR (a = 2 AND b = 3)
```

📌 ✅ 这也能命中复合索引 `(a, b)`

## ❗️三、优化器**不能**优化的典型场景

### ❌ 1. 完全跳过最左字段

```
-- 联合索引：(a, b)
SELECT * FROM t WHERE b = 2;
```

📌 无论优化器多聪明，都没法从 B+ 树中定位 b = 2，因为树是按 a → b 排序的

------

### ❌ 2. 范围查询中使用后续字段

```
-- 联合索引：(a, b, c)
SELECT * FROM t WHERE a = 1 AND b > 2 AND c = 3;
```

📌 虽然有 a，也有 c，但由于 **b 是范围条件**，优化器不会也不能推断 c 能否使用索引
 ⇒ c 这一段索引失效（**后续字段一律废**）

## ✅ 四、如何验证优化器是否生效？

使用 `EXPLAIN` 看执行计划中的 `key` 和 `key_len`：

```
EXPLAIN SELECT * FROM t WHERE b = 2 AND a = 1;
```

观察：

- `key`: 是否使用了联合索引 `(a, b)`
- `key_len`: 是否完整用了两个字段的长度（说明 a 和 b 都被用到了）
- `Extra`: 是否有 "Using where" / "Using index" / "Using index condition"

## ✅ 五、总结：你该怎么做？

| 做法                                    | 原因                   |
| --------------------------------------- | ---------------------- |
| 你写 SQL 时字段顺序尽量符合索引定义顺序 | 优化器能优化，但不能赌 |
| 想跨字段用索引？就别中间用范围查询      | 范围查询会截断索引使用 |
| 复杂条件下用 EXPLAIN 检查 key、key_len  | 靠猜不如靠数据说话     |

## 📌 最后一个建议：

> **别指望优化器拯救设计错误的索引，优化器只是补锅侠，不是你的架构师。**





