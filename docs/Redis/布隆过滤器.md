# 布隆过滤器是什么

## ✅ 一、布隆过滤器是什么？（定义 + 原理）

布隆过滤器（Bloom Filter）是一种**空间效率极高的概率型数据结构**，用于快速判断一个元素“是否可能存在”。

它的底层原理是：

- 通过多个哈希函数，将一个元素映射到一个位数组（bit array）上的多个位置；
- 查询时，检查这些位置是否都为 1；
  - 全为 1 → 可能存在；
  - 只要一个为 0 → 一定不存在；
- 因为可能哈希冲突，所以有 **误判率（False Positive）**。

## ✅ 二、布隆过滤器在缓存中干什么用？（业务目标）

布隆过滤器主要用于**防止缓存穿透**。

### ❓什么是缓存穿透？

是指：用户查询的数据既不在缓存中，也不在数据库中，例如恶意请求访问随机 ID。

如果每次都访问数据库，缓存就白搞了。

------

### 🎯 布隆过滤器的作用：

| 角色               | 作用                                   |
| ------------------ | -------------------------------------- |
| 放在缓存前         | 判断某个 key 是否“**可能合法**”        |
| 若判断“不可能存在” | 直接拒绝请求，**不查缓存、不查数据库** |
| 若判断“可能存在”   | 再走正常的缓存查询逻辑                 |

👉 **核心目标：减少无效请求对数据库的打击，保护后端系统**

## ✅ 三、布隆过滤器的优势和缺陷

| 优点                    | 缺点                         |
| ----------------------- | ---------------------------- |
| 空间占用极小（bit数组） | 有误判率：可能误认为存在     |
| 插入查询都极快（O(k)）  | 无法删除（除非用计数布隆）   |
| 支持大规模数据去重      | 元素查不到内容，只判断存在性 |
| 支持可扩容实现          | 位图打满误判率飙升           |

## ✅ 四、布隆过滤器满了怎么办？（面试闭环方案）

### 🎯 问题本质：

随着数据量增加，位图越来越满，误判率越来越高，最终什么都说“来过”，失效。

------

### ✅ 面试闭环式回答建议如下：

> 如果布隆过滤器打满了，我会根据业务容忍度和系统架构选择以下几种方案：

#### 🚀【方案 1】自动扩容（推荐）

> 使用 RedisBloom 的自动扩容机制，支持 `BLOOM.RESERVE` 设置误判率和容量，超限后**自动挂载新过滤器**，查询时会同时查询多个过滤器。

- ✅ 无需迁移历史数据
- ✅ 查询链路不中断
- ✅ 是当前 Redis + Spring 常用组合

------

#### 🔁【方案 2】滑动窗口布隆（短期唯一性需求）

> 按时间切分（比如每 10 分钟一个布隆），每次写入当前窗口，查时查近 N 个窗口。适合做行为记录去重（如短信防刷、接口幂等）

- ✅ 近似去重
- ✅ 可控过期
- ✅ 常用于日志、URL 去重

------

#### 🧠【方案 3】双缓冲布隆（定期切换）

> 保留两个布隆过滤器，当第一个饱和时，开启第二个作为新过滤器，同时旧的继续查一段时间后销毁。

- ✅ 查询不中断
- ✅ 新数据不丢失
- ❗内存压力更高

------

#### 🧮【方案 4】换用 Counting Bloom Filter

> 每个位是一个计数器而非布尔位，支持插入 + 删除，适用于某些有数据过期或删除需求的系统。

- ✅ 支持回滚
- ❗内存消耗更大（int vs bit）

## ✅ 五、总结一段可以直接复述的口语化答案（可背）

> 布隆过滤器是一种节省内存的概率型结构，用来判断某个 key 是否可能存在，常用于**防止缓存穿透**。它不存储具体值，只判断“可能存在”，因此会有误判，但不会漏判。它主要用于高并发下保护数据库，避免无效请求打穿缓存直接查库。<br><br>如果过滤器打满，我会采用 RedisBloom 自动扩容或时间窗口切换策略，保证查询不中断，误判率受控，实现一个完整的防护闭环。





# 布隆过滤器扩容的本质

## ✅ 二、那 RedisBloom 是怎么解决这个问题的？（重点）

它不是**替换原来的布隆过滤器结构**，而是：

> 🚨**挂载一个新的布隆过滤器，并保留旧的**！

### ✅ 每次扩容，不是替换，而是“挂多个子过滤器”

官方文档叫做：

> **Scalable Bloom Filter**（可扩展布隆）

它的行为如下：

| 操作                      | 实际动作                                     |
| ------------------------- | -------------------------------------------- |
| 你设置了误判率 + 初始容量 | 创建一个主布隆过滤器                         |
| 插入数据超过容量          | 创建一个新的子布隆（更大、更低误判率）       |
| 查询时                    | 轮询所有子布隆过滤器，任何一个命中都算“存在” |



### ✅ 每个子布隆：hash 函数独立 + 位图大小独立

每个子布隆内部有自己的：

- #### hash 基数（取决于位图大小）

- #### 误判率（越往后越低）

- #### bitmap

你可以理解为：
 **不是给一个布隆“换器官”，而是多养几个布隆并行养着用**

## ✅ 三、插入行为

每次插入，都会写入**最新的子布隆**（位图还没满的那个）

查询时会**同时查询所有布隆**。

所以：

- 不存在“迁移”
- 不存在“原数据失效”
- 不存在“hash 函数错乱”
- ✅ 新数据直接进新布隆
- ✅ 老数据继续保存在原布隆中

## ✅ 四、图示理解（面试可以画）：

```java
时间轴 →
      ┌────────┐
      │布隆1    │ → 容量 10000 → hash % 10000
      └────────┘
            ↓满了
                   ┌────────┐
                   │布隆2    │ → 容量 20000 → hash % 20000
                   └────────┘
                          ↓再满
                                 ┌────────┐
                                 │布隆3    │ → 容量 40000 → hash % 40000
                                 └────────┘

查询时：布隆1 ∪ 布隆2 ∪ 布隆3
```

------

## ✅ 五、答面试官怎么说？（推荐话术）

> 布隆过滤器扩容不是直接放大原来的 bitmap，那会导致 hash 函数错位、原数据失效。
>
> RedisBloom 的扩容是用 **Scalable Bloom Filter** 的方式实现的，即每次容量超限就挂一个新的子布隆过滤器，原数据保留在旧布隆，新数据写入新布隆。
>
> 每个子布隆都有自己的 hash 配置和 bitmap，查询时轮询所有子布隆来判断“是否可能存在”。
>
> 这样解决了误判率上升问题，同时避免 hash 错位和历史数据迁移的成本，查询逻辑保持一致，整体系统更稳定。



# 四种解决方式的本质

## ✅ ✅ ✅ 结论就是：

> 所有你听说过的布隆过滤器扩容方案 —— 不管说得多 fancy：
>
> 🚀「自动扩容」
>  🔁「双缓冲切换」
>  🕒「滑动时间窗口」
>  🧮「计数布隆替换」

👉 **本质全是：引入一个“新的、独立的布隆过滤器”，然后多个一起参与查询！**

## ✅ 为什么“独立”这么关键？

因为布隆过滤器结构天生不支持“增大容量后不变原有 hash 分布”。

你不能：

- 拿原来的 bit array 扩大后继续用原来的 hash 函数
- 否则 hash(x) % m 就完全错位

所以，唯一可靠的做法就是：

> ✅「保留旧布隆不动，新增新布隆，写入新数据，查所有布隆」
>  ❌「不能直接在原布隆上扩容 bitmap」

## ✅ 四种方案对比（共性标注 ✅ 多个布隆）

| 方案       | 描述                     | 是否多个独立布隆 | 插入方式       | 查询方式      |
| ---------- | ------------------------ | ---------------- | -------------- | ------------- |
| 🚀 自动扩容 | RedisBloom 挂多个 Filter | ✅ 是             | 只写最后一个   | 查所有        |
| 🔁 双缓冲   | 两个布隆交替使用         | ✅ 是             | 只写新布隆     | 查两个        |
| 🕒 滑动窗口 | 每 N 分钟一个布隆        | ✅ 是             | 写当前窗口布隆 | 查最近 N 个   |
| 🧮 计数布隆 | 可删除/过期的布隆版本    | ✅ 可分为多个     | 旧的过期后换新 | 查当前/查全部 |

## ✅ 一句话口语化总结（面试用）：

> 所有布隆过滤器的扩容、切换、滑动策略，本质上都是“新增一个独立的布隆”，和之前的布隆一起**并发参与查询**，避免数据迁移、避免误伤，并实现系统的平滑演进。这也是布隆设计上为了避免 hash 错位、误判失控而采取的通用思路。







